

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>check_functions &mdash; Beacon API 1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Beacon API
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../code.html">BeaconAPI autogenerated Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../instructions.html">Example usage</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Beacon API</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>check_functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for check_functions</h1><div class="highlight"><pre>
<span></span><span class="c1">#import logging</span>
<span class="c1">#import beacon_info</span>
<span class="c1">#import psycopg2</span>
<span class="c1">#import os</span>


<div class="viewcode-block" id="position"><a class="viewcode-back" href="../code.html#check_functions.position">[docs]</a><span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">startMin</span><span class="p">,</span> <span class="n">startMax</span><span class="p">,</span> <span class="n">endMin</span><span class="p">,</span> <span class="n">endMax</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    The `position()` function checks the values of the position parameters (start, startMin, startMax, end, endMain, endMax)</span>
<span class="sd">    and returns a position list `pos` that depending on the submitted parameters, either have one, two or four items.</span>

<span class="sd">    :type start: Integer</span>
<span class="sd">    :param start: The parameter `start` given in the request.</span>
<span class="sd">    :type end: Integer</span>
<span class="sd">    :param end: The parameter `end` given in the request.</span>
<span class="sd">    :type stertMin: Integer</span>
<span class="sd">    :param startMin: The parameter `startMin` given in the request.</span>
<span class="sd">    :type startMax: Integer</span>
<span class="sd">    :param startMax: The parameter `startMax` given in the request.</span>
<span class="sd">    :type endMin: Integer</span>
<span class="sd">    :param endMin: The parameter `endMin` given in the request.</span>
<span class="sd">    :type endMax: Integer</span>
<span class="sd">    :param endMax: The parameter `endMax` given in the request.</span>
<span class="sd">    :type pos: Array</span>
<span class="sd">    :return pos: An array containing the parameters that where given, the length depends on how many parameters where in the request.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># start --&gt; end</span>
            <span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pos</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># only start</span>
            <span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pos</span>
    <span class="c1"># fuzzy boundaries</span>
    <span class="k">if</span> <span class="n">startMin</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">startMax</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">endMin</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">endMax</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">startMin</span><span class="p">)</span>
        <span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">startMax</span><span class="p">)</span>
        <span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endMin</span><span class="p">)</span>
        <span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endMax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pos</span></div>

<div class="viewcode-block" id="alleleFind"><a class="viewcode-back" href="../code.html#check_functions.alleleFind">[docs]</a><span class="k">def</span> <span class="nf">alleleFind</span><span class="p">(</span><span class="n">datasetId</span><span class="p">,</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">allele</span><span class="p">,</span> <span class="n">variantType</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    The `alleleFind()` function queries the database with the submitted parameters and checks if it finds the allele in the right place.</span>
<span class="sd">    It returns True if found and False if not. It also returns the object to the row that was queried in the database.</span>

<span class="sd">    :type datasetId: String</span>
<span class="sd">    :param datasetId: The name of the data set.</span>
<span class="sd">    :type chromosome: String</span>
<span class="sd">    :param chromosome: The chromosome given in the `referenceName` parameter in the request.</span>
<span class="sd">    :type position:</span>
<span class="sd">    :param position: Array of the positional arguments given in the request.</span>
<span class="sd">    :type allele: String</span>
<span class="sd">    :param allele: The alternate allele tha`t is queried for.</span>
<span class="sd">    :type variantType:</span>
<span class="sd">    :param variantType: The variant type given in the request.</span>
<span class="sd">    :return boolean: The True or False answer from the query.</span>
<span class="sd">    :return row: The row from the database that has been queried.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">url</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;DATABASE_URL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="n">POSTGRES</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;user&#39;</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;DATABASE_USER&#39;</span><span class="p">],</span>
        <span class="s1">&#39;password&#39;</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;DATABASE_PASSWORD&#39;</span><span class="p">],</span>
        <span class="s1">&#39;database&#39;</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;DATABASE_NAME&#39;</span><span class="p">],</span>
        <span class="s1">&#39;host&#39;</span><span class="p">:</span> <span class="n">url</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">}</span>
    <span class="n">DB_URL</span> <span class="o">=</span> <span class="s1">&#39;postgresql://</span><span class="si">{user}</span><span class="s1">:</span><span class="si">{pw}</span><span class="s1">@</span><span class="si">{url}</span><span class="s1">/</span><span class="si">{db}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">user</span><span class="o">=</span><span class="n">POSTGRES</span><span class="p">[</span><span class="s1">&#39;user&#39;</span><span class="p">],</span> <span class="n">pw</span><span class="o">=</span><span class="n">POSTGRES</span><span class="p">[</span><span class="s1">&#39;password&#39;</span><span class="p">],</span> <span class="n">url</span><span class="o">=</span><span class="n">POSTGRES</span><span class="p">[</span><span class="s1">&#39;host&#39;</span><span class="p">],</span> <span class="n">db</span><span class="o">=</span><span class="n">POSTGRES</span><span class="p">[</span><span class="s1">&#39;database&#39;</span><span class="p">])</span>
    <span class="c1"># if alternateBases or variantType are not defined they are set to None</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39; * Opening connection to database&#39;</span><span class="p">)</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">psycopg2</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">DB_URL</span><span class="p">)</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">allele</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; * Execute SQL query: SELECT * FROM genomes WHERE dataset_id=</span><span class="si">{}</span><span class="s1"> AND chromosome=</span><span class="si">{}</span><span class="s1"> AND start=</span><span class="si">{}</span><span class="s1"> AND  type=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datasetId</span><span class="p">,</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">variantType</span><span class="p">))</span>
            <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;SELECT * FROM genomes WHERE dataset_id=</span><span class="si">%s</span><span class="s1"> AND chromosome=</span><span class="si">%s</span><span class="s1"> AND start=</span><span class="si">%s</span><span class="s1"> AND  type=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,[</span><span class="n">datasetId</span><span class="p">,</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">variantType</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; * Execute SQL query: SELECT * FROM genomes WHERE dataset_id=</span><span class="si">{}</span><span class="s1"> AND chromosome=</span><span class="si">{}</span><span class="s1"> AND start=</span><span class="si">{}</span><span class="s1"> AND &quot;end&quot;=</span><span class="si">{}</span><span class="s1"> AND type=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datasetId</span><span class="p">,</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">,</span> <span class="n">variantType</span><span class="p">))</span>
            <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;SELECT * FROM genomes WHERE dataset_id=</span><span class="si">%s</span><span class="s1"> AND chromosome=</span><span class="si">%s</span><span class="s1"> AND start=</span><span class="si">%s</span><span class="s1"> AND &quot;end&quot;=</span><span class="si">%s</span><span class="s1"> AND type=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,[</span><span class="n">datasetId</span><span class="p">,</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">,</span> <span class="n">variantType</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; * Execute SQL query: SELECT * FROM genomes WHERE dataset_id=</span><span class="si">{}</span><span class="s1"> AND chromosome=</span><span class="si">{}</span><span class="s1"> AND start&gt;=</span><span class="si">{}</span><span class="s1"> AND start&lt;=</span><span class="si">{}</span><span class="s1"> AND &quot;end&quot;&gt;=</span><span class="si">{}</span><span class="s1"> AND &quot;end&quot;&lt;=</span><span class="si">{}</span><span class="s1"> AND type=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datasetId</span><span class="p">,</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">variantType</span><span class="p">))</span>
            <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;SELECT * FROM genomes WHERE dataset_id=</span><span class="si">%s</span><span class="s1"> AND chromosome=</span><span class="si">%s</span><span class="s1"> AND start&gt;=</span><span class="si">%s</span><span class="s1"> AND start&lt;=</span><span class="si">%s</span><span class="s1"> AND &quot;end&quot;&gt;=</span><span class="si">%s</span><span class="s1"> AND &quot;end&quot;&lt;=</span><span class="si">%s</span><span class="s1"> AND type=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,[</span><span class="n">datasetId</span><span class="p">,</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">variantType</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">allele</span> <span class="o">!=</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; * Execute SQL query: SELECT * FROM genomes WHERE dataset_id=</span><span class="si">{}</span><span class="s1"> AND chromosome=</span><span class="si">{}</span><span class="s1"> AND start=</span><span class="si">{}</span><span class="s1"> AND  alternate=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datasetId</span><span class="p">,</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">allele</span><span class="p">))</span>
            <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;SELECT * FROM genomes WHERE dataset_id=</span><span class="si">%s</span><span class="s1"> AND chromosome=</span><span class="si">%s</span><span class="s1"> AND start=</span><span class="si">%s</span><span class="s1"> AND  alternate=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                        <span class="p">[</span><span class="n">datasetId</span><span class="p">,</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">allele</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; * Execute SQL query: SELECT * FROM genomes WHERE dataset_id=</span><span class="si">{}</span><span class="s1"> AND chromosome=</span><span class="si">{}</span><span class="s1"> AND start=</span><span class="si">{}</span><span class="s1"> AND &quot;end&quot;=</span><span class="si">{}</span><span class="s1"> AND alternate=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datasetId</span><span class="p">,</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">allele</span><span class="p">))</span>
            <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;SELECT * FROM genomes WHERE dataset_id=</span><span class="si">%s</span><span class="s1"> AND chromosome=</span><span class="si">%s</span><span class="s1"> AND start=</span><span class="si">%s</span><span class="s1"> AND &quot;end&quot;=</span><span class="si">%s</span><span class="s1"> AND alternate=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                        <span class="p">[</span><span class="n">datasetId</span><span class="p">,</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">allele</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; * Execute SQL query: SELECT * FROM genomes WHERE dataset_id=</span><span class="si">{}</span><span class="s1"> AND chromosome=</span><span class="si">{}</span><span class="s1"> AND start&gt;=</span><span class="si">{}</span><span class="s1"> AND start&lt;=</span><span class="si">{}</span><span class="s1"> AND &quot;end&quot;&gt;=</span><span class="si">{}</span><span class="s1"> AND &quot;end&quot;&lt;=</span><span class="si">{}</span><span class="s1">AND alternate=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datasetId</span><span class="p">,</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">allele</span><span class="p">))</span>
            <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
                <span class="s1">&#39;SELECT * FROM genomes WHERE dataset_id=</span><span class="si">%s</span><span class="s1"> AND chromosome=</span><span class="si">%s</span><span class="s1"> AND start&gt;=</span><span class="si">%s</span><span class="s1"> AND start&lt;=</span><span class="si">%s</span><span class="s1"> AND &quot;end&quot;&gt;=</span><span class="si">%s</span><span class="s1"> AND &quot;end&quot;&lt;=</span><span class="si">%s</span><span class="s1"> AND alternate=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="p">[</span><span class="n">datasetId</span><span class="p">,</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">allele</span><span class="p">])</span>

    <span class="n">row</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; * First matching row from query: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">row</span><span class="p">))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39; * Closing connection to database&#39;</span><span class="p">)</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; * Returning FALSE&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">row</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; * Returning TRUE&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">row</span></div>

<div class="viewcode-block" id="datasetAlleleResponseBuilder"><a class="viewcode-back" href="../code.html#check_functions.datasetAlleleResponseBuilder">[docs]</a><span class="k">def</span> <span class="nf">datasetAlleleResponseBuilder</span><span class="p">(</span><span class="n">datasetId</span><span class="p">,</span> <span class="n">referenceName</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">alternateBases</span><span class="p">,</span> <span class="n">variantType</span><span class="p">,</span> <span class="n">BeaconDataset</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    The `datasetAlleleResponseBuilder()` function calls the `alleleFind()` function and receives the answer to the exist parameter</span>
<span class="sd">    and the database object to the row in the database. If `exists` == False the function sets the `variantCount`, `sampleCount`,</span>
<span class="sd">    `callCount` and `frequency` to 0. And if `exists` == True the function gets the parameter values from the database.</span>

<span class="sd">    :type datasetId: String</span>
<span class="sd">    :param datasetId: The name of the data set.</span>
<span class="sd">    :type referenceName:</span>
<span class="sd">    :param referenceName: Reference name (chromosome). Accepting values 1-22, X, Y so follows Ensembl chromosome naming convention.</span>
<span class="sd">    :type pos: Array</span>
<span class="sd">    :param pos: Array of the positional arguments given in the request.</span>
<span class="sd">    :type alternateBases: String</span>
<span class="sd">    :param alternateBases: The bases that appear instead of the reference bases, given in the request.</span>
<span class="sd">    :type variantType: String</span>
<span class="sd">    :param variantType: The variant type given in the request.</span>
<span class="sd">    :type BeaconDataset: Array</span>
<span class="sd">    :param BeaconDataset: Array of the names of the data sets in the database.</span>
<span class="sd">    :type datasetAlleleResponse: Dict</span>
<span class="sd">    :return: datasetAlleleResponse: Dict of the response that has been constructed.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">BeaconDataset</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">datasetId</span> <span class="ow">in</span> <span class="n">i</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]:</span>
            <span class="k">break</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39; * Calling function alleleFind()&#39;</span><span class="p">)</span>
    <span class="n">exists</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="n">alleleFind</span><span class="p">(</span><span class="n">datasetId</span><span class="p">,</span> <span class="n">referenceName</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">alternateBases</span><span class="p">,</span> <span class="n">variantType</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39; * Returning from function alleleFind()&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">exists</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">variantCount</span><span class="p">,</span> <span class="n">sampleCount</span><span class="p">,</span> <span class="n">callCount</span><span class="p">,</span> <span class="n">frequency</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span> <span class="c1"># does not alter the database only the representation</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">frequency</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
        <span class="n">sampleCount</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>
        <span class="n">callCount</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
        <span class="n">variantCount</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>

    <span class="n">datasetAlleleResponse</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;datasetId&#39;</span><span class="p">:</span> <span class="n">datasetId</span><span class="p">,</span>
        <span class="s1">&#39;exists&#39;</span><span class="p">:</span> <span class="n">exists</span><span class="p">,</span>
        <span class="s1">&#39;frequency&#39;</span><span class="p">:</span> <span class="n">frequency</span><span class="p">,</span>
        <span class="s1">&#39;variantCount&#39;</span><span class="p">:</span> <span class="n">variantCount</span><span class="p">,</span>
        <span class="s1">&#39;callCount&#39;</span><span class="p">:</span> <span class="n">callCount</span><span class="p">,</span>
        <span class="s1">&#39;sampleCount&#39;</span><span class="p">:</span> <span class="n">sampleCount</span><span class="p">,</span>
        <span class="s1">&#39;note&#39;</span><span class="p">:</span> <span class="n">BeaconDataset</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;description&#39;</span><span class="p">],</span>
        <span class="s1">&#39;externalUrl&#39;</span><span class="p">:</span> <span class="n">BeaconDataset</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;externalUrl&#39;</span><span class="p">],</span>
        <span class="s1">&#39;info&#39;</span><span class="p">:</span> <span class="n">BeaconDataset</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;info&#39;</span><span class="p">],</span>
        <span class="s1">&#39;error&#39;</span><span class="p">:</span> <span class="n">error</span>
    <span class="p">}</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39; * Returning datasetAlleleResponse&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">datasetAlleleResponse</span></div>

<div class="viewcode-block" id="checkParameters"><a class="viewcode-back" href="../code.html#check_functions.checkParameters">[docs]</a><span class="k">def</span> <span class="nf">checkParameters</span><span class="p">(</span><span class="n">referenceName</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">startMin</span><span class="p">,</span> <span class="n">startMax</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">endMin</span><span class="p">,</span> <span class="n">endMax</span><span class="p">,</span> <span class="n">referenceBases</span><span class="p">,</span> <span class="n">alternateBases</span><span class="p">,</span> <span class="n">variantType</span><span class="p">,</span><span class="n">assemblyId</span><span class="p">,</span> <span class="n">datasetIds</span><span class="p">,</span> <span class="n">includeDatasetResponses</span><span class="p">,</span> <span class="n">error_</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    The `checkParameters()` function validates the submitted parameters values and checks if required parameters are missing.</span>
<span class="sd">    It calls the appropriate `BeaconError` method if something is wrong.</span>

<span class="sd">    :type referenceName: String</span>
<span class="sd">    :param referenceName: Reference name (chromosome). Accepting values 1-22, X, Y so follows Ensembl chromosome naming convention.</span>
<span class="sd">    :type start: Integer</span>
<span class="sd">    :param start:</span>
<span class="sd">            I. START ONLY:</span>

<span class="sd">            - for single positions, e.g. the `start` of a specified sequence alteration where the size is given through the specified `alternateBases`</span>
<span class="sd">            - typical use are queries for SNV and small InDels</span>
<span class="sd">            - the use of `start` without an `end` parameter requires the use of `referenceBases`</span>
<span class="sd">            II. START AND END:</span>

<span class="sd">            - special use case for exactly determined structural changes</span>
<span class="sd">    :type startMin: Integer</span>
<span class="sd">    :param startMin: Minimum start coordinate</span>
<span class="sd">            - startMin + startMax + endMin + endMax:</span>
<span class="sd">            - for querying imprecise positions (e.g. identifying all structural variants starting anywhere between `startMin` &lt;-&gt; `startMax`, and ending anywhere between `endMin` &lt;-&gt; `endMax`</span>
<span class="sd">            - single or double sided precise matches can be achieved by setting `startMin` = `startMax` OR `endMin` = `endMax`</span>
<span class="sd">    :type startMax: Integer</span>
<span class="sd">    :param startMax: Maximum start coordinate. See `startMin`.</span>
<span class="sd">    :type end: Integer</span>
<span class="sd">    :param end: Precise end coordinate. See `start`.</span>
<span class="sd">    :type endMin: Integer</span>
<span class="sd">    :param endMin: Minimum end coordinate. See `startMin`.</span>
<span class="sd">    :type endMax: Integer</span>
<span class="sd">    :param endMax: Maximum end coordinate. See `startMin`.</span>
<span class="sd">    :type referenceBases: String</span>
<span class="sd">    :param referenceBases: Reference bases for this variant (starting from `start`). Accepted values: [ACGT]* When querying for variants without specific base alterations (e.g. imprecise structural variants with separate variantType as well as startMin &amp; endMin ... parameters), the use of a single &quot;N&quot; value is required. See the REF field in VCF 4.2 specification.</span>
<span class="sd">    :type alternateBases: String</span>
<span class="sd">    :param alternateBases: The bases that appear instead of the reference bases. Accepted values: [ACGT]* or N.</span>
<span class="sd">            Symbolic ALT alleles (DEL, INS, DUP, INV, CNV, DUP:TANDEM, DEL:ME, INS:ME) will be represented in `variantType`.</span>
<span class="sd">            See the ALT field in VCF 4.2 specification</span>
<span class="sd">            Either `alternateBases` OR `variantType` is REQUIRED</span>
<span class="sd">    :type variantType: String</span>
<span class="sd">    :param variantType: The `variantType` is used to denote e.g. structural variants.</span>
<span class="sd">            Either `alternateBasesÂ´ OR `variantType` is REQUIRED</span>
<span class="sd">    :type assemblyId: String</span>
<span class="sd">    :param assemblyId: Assembly identifier</span>
<span class="sd">    :type datasetIds: String</span>
<span class="sd">    :param datasetIds: Identifiers of data sets, as defined in `BeaconDataset`. In case assemblyId doesn&#39;t match requested dataset(s) error will be raised (400 Bad request). If this field is not specified, all datasets should be queried.</span>
<span class="sd">    :type includeDatasetResponses: String</span>
<span class="sd">    :param includeDatasetResponses: Indicator of whether responses for individual data sets (`datasetAlleleResponses`) should be included in the response (`BeaconAlleleResponse`) to this request or not. If null (not specified), the default value of NONE is assumed.</span>
<span class="sd">            Accepted values : [&#39;ALL&#39;, &#39;HIT&#39;, &#39;MISS&#39;, &#39;NONE&#39;]</span>
<span class="sd">    :type error_: Object</span>
<span class="sd">    :param error_: Error object for the error handler.</span>
<span class="sd">    :type datasetAlleleResponses: Dict</span>
<span class="sd">    :return datasetAlleleResponses: Dict of the response.</span>
<span class="sd">    :type true_datasetAlleleResponses: Dict</span>
<span class="sd">    :return true_datasetAlleleResponses: Dict of those responses that give `exists` = True.</span>
<span class="sd">    :type false_datasetAlleleResponses: Dict</span>
<span class="sd">    :return false_datasetAlleleResponses: Dict of those responses that give `exists` = False.</span>
<span class="sd">    :type includeDatasetResponses: String</span>
<span class="sd">    :return includeDatasetResponses: The `includeDatasetResponses` from the request.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">refname</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">,</span> <span class="s1">&#39;6&#39;</span><span class="p">,</span> <span class="s1">&#39;7&#39;</span><span class="p">,</span> <span class="s1">&#39;8&#39;</span><span class="p">,</span> <span class="s1">&#39;9&#39;</span><span class="p">,</span> <span class="s1">&#39;10&#39;</span><span class="p">,</span> <span class="s1">&#39;11&#39;</span><span class="p">,</span> <span class="s1">&#39;12&#39;</span><span class="p">,</span> <span class="s1">&#39;13&#39;</span><span class="p">,</span> <span class="s1">&#39;14&#39;</span><span class="p">,</span> <span class="s1">&#39;15&#39;</span><span class="p">,</span> <span class="s1">&#39;16&#39;</span><span class="p">,</span> <span class="s1">&#39;17&#39;</span><span class="p">,</span> <span class="s1">&#39;18&#39;</span><span class="p">,</span> <span class="s1">&#39;19&#39;</span><span class="p">,</span> <span class="s1">&#39;20&#39;</span><span class="p">,</span> <span class="s1">&#39;21&#39;</span><span class="p">,</span> <span class="s1">&#39;22&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">]</span>
    <span class="n">datasetresponses</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;HIT&#39;</span><span class="p">,</span> <span class="s1">&#39;MISS&#39;</span><span class="p">,</span> <span class="s1">&#39;NONE&#39;</span><span class="p">]</span>
    <span class="n">assembliIds</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;GRCh37&#39;</span><span class="p">,</span> <span class="s1">&#39;GRCh38&#39;</span><span class="p">,</span> <span class="s1">&#39;grch37&#39;</span><span class="p">,</span> <span class="s1">&#39;grch38&#39;</span><span class="p">]</span>
    <span class="n">Bases</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">]</span>  <span class="c1"># The Zero is there to validate that it is missing</span>
    <span class="n">variantTypes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;DEL&#39;</span><span class="p">,</span> <span class="s1">&#39;INS&#39;</span><span class="p">,</span> <span class="s1">&#39;DUP&#39;</span><span class="p">,</span> <span class="s1">&#39;INV&#39;</span><span class="p">,</span> <span class="s1">&#39;CNV&#39;</span><span class="p">,</span> <span class="s1">&#39;SNP&#39;</span><span class="p">,</span> <span class="s1">&#39;DUP:TANDEM&#39;</span><span class="p">,</span> <span class="s1">&#39;DEL:ME&#39;</span><span class="p">,</span> <span class="s1">&#39;INS:ME&#39;</span><span class="p">]</span>
    <span class="n">datasetAlleleResponses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">datasetIds_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Beacon</span> <span class="o">=</span> <span class="n">beacon_info</span><span class="o">.</span><span class="n">constructor</span><span class="p">()</span>
    <span class="n">BeaconDataset</span> <span class="o">=</span> <span class="n">Beacon</span><span class="p">[</span><span class="s1">&#39;dataset&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">dset</span> <span class="ow">in</span> <span class="n">BeaconDataset</span><span class="p">:</span>
        <span class="n">datasetIds_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dset</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>

    <span class="n">pos</span> <span class="o">=</span> <span class="n">position</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">startMin</span><span class="p">,</span> <span class="n">startMax</span><span class="p">,</span> <span class="n">endMin</span><span class="p">,</span> <span class="n">endMax</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; * The position() function returned the array: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>

    <span class="c1"># check if referenceName parameter is missing</span>
    <span class="k">if</span> <span class="n">referenceName</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: Missing mandatory parameter referenceName&#39;</span><span class="p">)</span>
        <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;Missing mandatory parameter referenceName&#39;</span><span class="p">)</span>
    <span class="c1"># check if referenceName is valid</span>
    <span class="k">elif</span> <span class="n">referenceName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">refname</span><span class="p">:</span>
        <span class="c1">#if an error occures the &#39;exists&#39; must be &#39;null&#39;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: referenceName not valid&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="nb">set</span> <span class="ow">in</span> <span class="n">datasetAlleleResponses</span><span class="p">:</span>
            <span class="nb">set</span><span class="p">[</span><span class="s1">&#39;exists&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;referenceName not valid&#39;</span><span class="p">)</span>



    <span class="c1"># check if start/startMin parameter is missing</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">startMin</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: Missing mandatory parameter start or startMin&#39;</span><span class="p">)</span>
            <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;Missing mandatory parameter start or startMin&#39;</span><span class="p">)</span>
    <span class="c1"># check if the positional arguments are valid</span>
    <span class="k">elif</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: start not valid&#39;</span><span class="p">)</span>
        <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;start not valid&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">startMin</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: startMin not valid&#39;</span><span class="p">)</span>
        <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;startMin not valid&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">startMax</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: startMax not valid&#39;</span><span class="p">)</span>
        <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;startMax not valid&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">endMin</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: endMin not valid&#39;</span><span class="p">)</span>
        <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;endMin not valid&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">endMax</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: endMax not valid&#39;</span><span class="p">)</span>
        <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;endMax not valid&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: end not valid&#39;</span><span class="p">)</span>
        <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;end not valid&#39;</span><span class="p">)</span>



    <span class="c1"># check if referenceBases parameter is missing</span>
    <span class="k">if</span> <span class="n">referenceBases</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: Missing mandatory parameter referenceBases&#39;</span><span class="p">)</span>
        <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;Missing mandatory parameter referenceBases&#39;</span><span class="p">)</span>
    <span class="c1"># check if the string items in the referenceBases are valid</span>
    <span class="k">for</span> <span class="n">nucleotide2</span> <span class="ow">in</span> <span class="n">referenceBases</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nucleotide2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Bases</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: referenceBases not valid&#39;</span><span class="p">)</span>
            <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;referenceBases not valid&#39;</span><span class="p">)</span>



    <span class="c1"># check if alternateBases parameter is missing</span>
    <span class="k">if</span> <span class="n">alternateBases</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
        <span class="c1"># if alternateBases is missing, check if variantType is missing</span>
        <span class="k">if</span> <span class="n">variantType</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: Missing mandatory parameter alternateBases or variantType&#39;</span><span class="p">)</span>
            <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;Missing mandatory parameter alternateBases or variantType&#39;</span><span class="p">)</span>
        <span class="c1"># check if variantType parameter is valid</span>
        <span class="k">elif</span> <span class="n">variantType</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variantTypes</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: variantType not valid&#39;</span><span class="p">)</span>
            <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;variantType not valid&#39;</span><span class="p">)</span>
    <span class="c1"># check if the string items in the alternateBases are valid</span>
    <span class="k">for</span> <span class="n">nucleotide1</span> <span class="ow">in</span> <span class="n">alternateBases</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nucleotide1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Bases</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: alternateBases not valid&#39;</span><span class="p">)</span>
            <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;alternateBases not valid&#39;</span><span class="p">)</span>


    <span class="c1"># check if assemblyId is missing</span>
    <span class="k">if</span> <span class="n">assemblyId</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: Missing mandatory parameter assemblyId&#39;</span><span class="p">)</span>
        <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;Missing mandatory parameter assemblyId&#39;</span><span class="p">)</span>
    <span class="c1"># check if assemblyId parameter is valid</span>
    <span class="k">elif</span> <span class="n">assemblyId</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">assembliIds</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: assemblyId not valid&#39;</span><span class="p">)</span>
        <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;assemblyId not valid&#39;</span><span class="p">)</span>



    <span class="c1"># check if includeDataserResponses is missing</span>
    <span class="k">if</span> <span class="n">includeDatasetResponses</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">datasetresponses</span><span class="p">:</span>
        <span class="c1"># if an error occurs the &#39;exists&#39; must be &#39;null&#39;</span>
        <span class="k">for</span> <span class="nb">set</span> <span class="ow">in</span> <span class="n">datasetAlleleResponses</span><span class="p">:</span>
            <span class="nb">set</span><span class="p">[</span><span class="s1">&#39;exists&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: includeDatasetResponses not valid&#39;</span><span class="p">)</span>
        <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;includeDatasetResponses not valid&#39;</span><span class="p">)</span>


    <span class="c1"># checks if there are datasetIds given. If there are, then check if the the datasetIds are in the database Table.</span>
    <span class="c1"># If not give ERROR. If they are correct, build a response for each data set that is correct.</span>
    <span class="k">if</span> <span class="n">datasetIds</span><span class="p">:</span>
        <span class="k">for</span> <span class="nb">set</span> <span class="ow">in</span> <span class="n">datasetIds</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">set</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">datasetIds_list</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; * ERROR BAD REQUEST: datasetId not valid&#39;</span><span class="p">)</span>
                <span class="n">error_</span><span class="o">.</span><span class="n">bad_request</span><span class="p">(</span><span class="s1">&#39;datasetId not valid&#39;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; * Started building datasetAlleleResponse for: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">set</span><span class="p">))</span>
            <span class="n">datasetAlleleResponses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">datasetAlleleResponseBuilder</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="n">referenceName</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">alternateBases</span><span class="p">,</span> <span class="n">variantType</span><span class="p">,</span> <span class="n">BeaconDataset</span><span class="p">))</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; * Finnished building datasetAlleleResponse for: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">set</span><span class="p">))</span>
    <span class="c1"># if no data sets where given, it will query all data sets in the database</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">datasetIds</span> <span class="o">=</span> <span class="n">datasetIds_list</span>
        <span class="k">for</span> <span class="nb">set</span> <span class="ow">in</span> <span class="n">datasetIds</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; * Started building datasetAlleleResponse for: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">set</span><span class="p">))</span>
            <span class="n">datasetAlleleResponses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">datasetAlleleResponseBuilder</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="n">referenceName</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">alternateBases</span><span class="p">,</span> <span class="n">variantType</span><span class="p">,</span> <span class="n">BeaconDataset</span><span class="p">))</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; * Finnished building datasetAlleleResponse for: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">set</span><span class="p">))</span>




    <span class="c1"># creates empty lists for specific datasetResponses</span>
    <span class="n">false_datasetAlleleResponses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">true_datasetAlleleResponses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># fills the lists with the responses</span>
    <span class="k">for</span> <span class="n">response</span> <span class="ow">in</span> <span class="n">datasetAlleleResponses</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">response</span><span class="p">[</span><span class="s1">&#39;exists&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">false_datasetAlleleResponses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">response</span><span class="p">[</span><span class="s1">&#39;exists&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">true_datasetAlleleResponses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>



    <span class="k">return</span> <span class="n">datasetAlleleResponses</span><span class="p">,</span> <span class="n">true_datasetAlleleResponses</span><span class="p">,</span> <span class="n">false_datasetAlleleResponses</span><span class="p">,</span> <span class="n">includeDatasetResponses</span></div>


<div class="viewcode-block" id="checkifdatasetisTrue"><a class="viewcode-back" href="../code.html#check_functions.checkifdatasetisTrue">[docs]</a><span class="k">def</span> <span class="nf">checkifdatasetisTrue</span><span class="p">(</span><span class="n">datasets</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    The `checkifdatasetisTrue()` function checks the individual data sets and returns True if any of the data sets have</span>
<span class="sd">    exists == True.</span>

<span class="sd">    :type datasets: Dict</span>
<span class="sd">    :param datasets: Dict of the response from the data set.</span>
<span class="sd">    :return: boolean</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="s1">&#39;exists&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="checkInclude"><a class="viewcode-back" href="../code.html#check_functions.checkInclude">[docs]</a><span class="k">def</span> <span class="nf">checkInclude</span><span class="p">(</span><span class="n">includeDatasetResponses</span><span class="p">,</span> <span class="n">alldatasets</span><span class="p">,</span> <span class="n">trurdatasets</span><span class="p">,</span> <span class="n">falsedatasets</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    The function returns those data set responses that the `includeDatasetResponses` parameter decides</span>

<span class="sd">    :type includeDatasetResponses: String</span>
<span class="sd">    :param includeDatasetResponses: The `includeDatasetResponses` from the request.</span>
<span class="sd">    :type alldatasets: Dict</span>
<span class="sd">    :param alldatasets: Dicts of all the responses.</span>
<span class="sd">    :type trurdatasets: Dict</span>
<span class="sd">    :param trurdatasets: Dicts of all the data sets that have `exists` = True.</span>
<span class="sd">    :type falsedatasets: Dict</span>
<span class="sd">    :param falsedatasets: Dicts of all the data sets that have `exists` = False.</span>
<span class="sd">    :type alldatasets: Dict</span>
<span class="sd">    :return alldatasets: Dicts of all the responses.</span>
<span class="sd">    :type trurdatasets: Dict</span>
<span class="sd">    :return trurdatasets: Dicts of all the data sets that have `exists` = True.</span>
<span class="sd">    :type falsedatasets: Dict</span>
<span class="sd">    :return falsedatasets: Dicts of all the data sets that have `exists` = False.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">includeDatasetResponses</span> <span class="o">==</span> <span class="s1">&#39;ALL&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">alldatasets</span>
    <span class="k">elif</span> <span class="n">includeDatasetResponses</span> <span class="o">==</span> <span class="s1">&#39;NONE&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">elif</span> <span class="n">includeDatasetResponses</span> <span class="o">==</span> <span class="s1">&#39;HIT&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">trurdatasets</span>
    <span class="k">elif</span> <span class="n">includeDatasetResponses</span> <span class="o">==</span> <span class="s1">&#39;MISS&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">falsedatasets</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Kasper Keinanen.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>